#!/usr/bin/env python


'''
this version performs volume manipulation through python

rotate tomograms so that the missing wedge region corresponding to normal missing wedge masks

generate an json file containing the list of rotated tomograms

perform visual inspection to make sure the correctness of rotation


to initialize
source-matlab
source-python
source-tomominer--native


~/ln/tomominer/tomominer/pick/preprocessing/tomogram_prepare__python.py
'''


import os, json

if __name__ == '__main__':


    with open('tomogram_prepare__config.json') as f:    op = json.load(f)


    if not os.path.isdir(op['out_dir']):        os.makedirs(op['out_dir'])

    if op['check_source_file']:
        import pymatlab
        session = pymatlab.session_factory(options='-nodesktop -nodisplay')
        session.run( 'addpath(  genpath(\'%s\') )'%(op['matlab_tom_2008_code_path'],) )
    else:
        session = None

 
    # scan and obtain file ids
    ids = [_ for _ in os.listdir(op['original_tomogram_dir']) if (not os.path.isdir(_)) ]
    ids = [_ for _ in ids if (_.endswith('.rec') and (not _.startswith('_')))]
    ids = [int(_.split('.')[0]) for _ in ids]

    import pickle
    import numpy as N
    import tomominer.io.file as IF
    import tomominer.io.read_mrc__check as IR

    tom_list = []
    for tom_i in ids:

        if ('selected_tomogram_ids' in op) and (tom_i not in set(op['selected_tomogram_ids'])):     continue

        print '---------------------------'
        print 'processing tomogram', tom_i

        rec_file_name = os.path.join(op['original_tomogram_dir'], '%d.rec'%(tom_i,))

        #v = IF.read_mrc__chimera(rec_file_name)

        if op['check_source_file'] and IR.read_mrc__check(rec_file_name, sub_region=[[0,400], [0,400], [0,400]], matlab_session=session, show_progress=True) > 0:            raise Exception('IF.read_mrc() cannot correctly read the volumeric data generated by IMOD!')


        im = IF.read_mrc(rec_file_name, read_data=False)
        header_file = os.path.join(op['out_dir'], '%d-header.pickle'%(tom_i))
        with open(header_file, 'w') as f:      pickle.dump(im, f)

        result_file = os.path.join(op['out_dir'], '%d.rec'%(tom_i))
        tilt_angle_file = os.path.join(op['original_tomogram_dir'], '%d.tlt'%(tom_i))

        segment_file = os.path.realpath(os.path.join(op['original_tomogram_dir'], '%d.Labels.surf'%(tom_i,)))

        tom = {}
        tom['id'] = tom_i
        tom['vol_file_original'] = os.path.realpath(rec_file_name)
        tom['vol_file'] = os.path.realpath(result_file)
        if os.path.isfile(tilt_angle_file):         tom['tilt_angle_file'] = os.path.realpath(tilt_angle_file)
        tom['header_file'] = os.path.realpath(header_file)
        if os.path.isfile(segment_file):        tom['segment_file'] = os.path.realpath(segment_file)
        tom['voxel_spacing'] = (im['header']['MRC']['xlen'] / im['header']['MRC']['nx']) * 0.1          # voxel spacing in nm unit
        tom_list.append(tom)

        if os.path.isfile(result_file):     continue

        os.symlink(os.path.realpath(rec_file_name), result_file)     # just make a symbolic link to original file


    with open('tomogram_prepare__out.json', 'w') as f:    json.dump(tom_list, f, indent=2)




'''

# test the equavalence between rotation and permutation+rot90




import matplotlib
matplotlib.use('Qt4Agg')
import tomominer.image.vol as CV


import tomominer.model.util as MU
v = MU.generate_toy_model(model_id=101)
CV.dsp_cub(v)


import numpy as N
vr = N.transpose(v, [2,0,1])
vr = N.rot90(vr)
CV.dsp_cub(vr)

# after plotting v and vr with markers, you can then verify if the combination of transpose and rot90 is a valid rotation, using your fingers on your left hand




import tomominer.geometry.rotate as GR
vrt = GR.rotate(v, angle=[-N.pi/2, N.pi/2, 0])
CV.dsp_cub(vrt)



'''
    
